# 扩展练习设计方案

## Challenge1：UNIX PIPE机制设计方案

### 一、概述

UNIX管道(Pipe)是一种进程间通信(IPC)机制，允许一个进程的输出直接作为另一个进程的输入。管道是单向的、先进先出(FIFO)的数据通道，具有同步和互斥特性。

### 二、数据结构设计

#### 1. 管道缓冲区结构体

```c
#define PIPE_BUF_SIZE 4096

struct pipe_buffer {
    char data[PIPE_BUF_SIZE];
    size_t cnt;
    size_t rpos;
    size_t wpos;
};
```

**说明：**
- `data`: 环形缓冲区，存储管道数据
- `cnt`: 缓冲区中当前数据字节数
- `rpos`: 读指针位置
- `wpos`: 写指针位置

#### 2. 管道结构体

```c
struct pipe {
    struct pipe_buffer buffer;
    int readfd;
    int writefd;
    int readers;
    int writers;
    semaphore_t mutex;
    semaphore_t empty;
    semaphore_t full;
    bool closed;
};
```

**说明：**
- `buffer`: 管道缓冲区
- `readfd`: 读端文件描述符
- `writefd`: 写端文件描述符
- `readers`: 读进程计数
- `writers`: 写进程计数
- `mutex`: 互斥信号量，保护缓冲区访问
- `empty`: 同步信号量，表示空闲缓冲区空间
- `full`: 同步信号量，表示可用数据量
- `closed`: 管道关闭标志

#### 3. 扩展文件结构体

在现有的`struct file`基础上扩展：

```c
struct file {
    enum {
        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,
    } status;
    bool readable;
    bool writable;
    int fd;
    off_t pos;
    struct inode *node;
    int open_count;
    struct pipe *pipe;
};
```

**说明：**
- 新增`pipe`字段，指向管道结构体（如果是管道文件）

### 三、接口设计

#### 1. 管道创建接口

```c
int sys_pipe(int fd[2]);
```

**语义：**
- 创建一个匿名管道
- 返回两个文件描述符：fd[0]用于读，fd[1]用于写
- 成功返回0，失败返回错误码

**实现要点：**
1. 分配管道结构体内存
2. 初始化缓冲区和信号量
3. 分配两个文件描述符
4. 设置读写权限

#### 2. 管道读接口

```c
int pipe_read(struct pipe *pipe, void *buf, size_t len);
```

**语义：**
- 从管道读取数据到缓冲区buf
- 如果管道为空且存在写进程，则阻塞等待
- 如果管道为空且无写进程，返回0（EOF）
- 返回实际读取的字节数

**实现要点：**
1. 获取full信号量（等待数据）
2. 获取mutex信号量（互斥访问）
3. 从缓冲区读取数据
4. 更新读指针和计数
5. 释放mutex信号量
6. 释放empty信号量（通知有空间）

#### 3. 管道写接口

```c
int pipe_write(struct pipe *pipe, void *buf, size_t len);
```

**语义：**
- 将数据从缓冲区buf写入管道
- 如果管道已满，则阻塞等待空间
- 如果管道无读进程，返回EPIPE错误
- 返回实际写入的字节数

**实现要点：**
1. 检查是否存在读进程
2. 获取empty信号量（等待空间）
3. 获取mutex信号量（互斥访问）
4. 向缓冲区写入数据
5. 更新写指针和计数
6. 释放mutex信号量
7. 释放full信号量（通知有数据）

#### 4. 管道关闭接口

```c
int pipe_close(struct pipe *pipe, int fd);
```

**语义：**
- 关闭管道的一端
- 如果关闭写端，唤醒所有读进程
- 如果关闭读端，唤醒所有写进程
- 当读写端都关闭时，释放管道资源

**实现要点：**
1. 根据fd判断关闭读端还是写端
2. 更新readers或writers计数
3. 如果关闭写端，唤醒等待的读进程
4. 如果关闭读端，唤醒等待的写进程
5. 如果readers和writers都为0，释放管道资源

### 四、同步互斥处理

#### 1. 生产者-消费者模型

管道采用经典的生产者-消费者模型：
- **生产者（写进程）**：向管道写入数据
- **消费者（读进程）**：从管道读取数据

#### 2. 同步机制

使用三个信号量实现同步：

```c
semaphore_t mutex;  // 互斥信号量，初值为1
semaphore_t empty;  // 空闲缓冲区信号量，初值为PIPE_BUF_SIZE
semaphore_t full;   // 满缓冲区信号量，初值为0
```

**同步规则：**
- 写进程：P(empty) → P(mutex) → 写数据 → V(mutex) → V(full)
- 读进程：P(full) → P(mutex) → 读数据 → V(mutex) → V(empty)

#### 3. 互斥处理

- `mutex`信号量确保同一时刻只有一个进程访问缓冲区
- 防止读写操作同时修改缓冲区指针和计数

#### 4. 死锁预防

- 严格按照信号量获取顺序操作：先获取同步信号量(empty/full)，再获取互斥信号量(mutex)
- 避免在持有互斥锁时进行可能阻塞的操作

#### 5. 边界情况处理

1. **管道满时写操作**：
   - 阻塞写进程，等待读进程释放空间
   - 使用`empty`信号量实现

2. **管道空时读操作**：
   - 如果存在写进程，阻塞读进程等待数据
   - 如果无写进程，返回EOF
   - 使用`full`信号量和`writers`计数实现

3. **写端关闭**：
   - 唤醒所有阻塞的读进程
   - 读进程读到EOF后退出

4. **读端关闭**：
   - 唤醒所有阻塞的写进程
   - 写进程收到SIGPIPE信号或返回EPIPE错误

### 五、实现流程

#### pipe系统调用流程

```
sys_pipe()
  ├─ 分配pipe结构体
  ├─ 初始化缓冲区和信号量
  ├─ 分配fd[0]（读端）
  ├─ 分配fd[1]（写端）
  └─ 返回fd数组
```

#### 读流程

```
pipe_read()
  ├─ P(full) - 等待数据
  ├─ P(mutex) - 获取互斥锁
  ├─ 从缓冲区读取数据
  ├─ 更新rpos和cnt
  ├─ V(mutex) - 释放互斥锁
  └─ V(empty) - 通知有空间
```

#### 写流程

```
pipe_write()
  ├─ 检查readers > 0
  ├─ P(empty) - 等待空间
  ├─ P(mutex) - 获取互斥锁
  ├─ 向缓冲区写入数据
  ├─ 更新wpos和cnt
  ├─ V(mutex) - 释放互斥锁
  └─ V(full) - 通知有数据
```

### 六、与VFS的集成

#### 1. 扩展inode操作

```c
struct inode_ops {
    ...
    int (*vop_read)(struct inode *node, struct iobuf *iob);
    int (*vop_write)(struct inode *node, struct iobuf *iob);
    int (*vop_close)(struct inode *node);
    ...
};
```

#### 2. 创建管道inode

```c
int pipe_alloc(struct inode **node_store);
```

**语义：**
- 创建管道inode
- 初始化管道结构体
- 返回inode指针

---

## Challenge2：UNIX软连接和硬连接机制设计方案

### 一、概述

UNIX文件系统支持两种链接机制：
- **硬链接(Hard Link)**：多个目录项指向同一个inode，共享相同的数据块
- **软连接(Symbolic Link)**：特殊的文件，内容是另一个文件的路径

### 二、数据结构设计

#### 1. 扩展SFS磁盘inode结构

在现有的`struct sfs_disk_inode`基础上扩展：

```c
struct sfs_disk_inode {
    uint32_t size;
    uint16_t type;
    uint16_t nlinks;
    uint32_t blocks;
    uint32_t direct[SFS_NDIRECT];
    uint32_t indirect;
    uint32_t link_ino;  // 新增：软链接目标inode号
    char link_path[SFS_MAX_LINK_PATH_LEN + 1];  // 新增：软链接目标路径
};
```

**说明：**
- `link_ino`: 软链接目标的inode号（用于快速查找）
- `link_path`: 软链接目标的完整路径

#### 2. 扩展SFS文件类型

```c
#define SFS_TYPE_FILE    1
#define SFS_TYPE_DIR     2
#define SFS_TYPE_LINK    3
#define SFS_TYPE_SYMLINK 4  // 新增：符号链接类型
```

#### 3. 扩展SFS内存inode结构

```c
struct sfs_inode {
    struct sfs_disk_inode *din;
    uint32_t ino;
    bool dirty;
    int reclaim_count;
    semaphore_t sem;
    list_entry_t inode_link;
    list_entry_t hash_link;
    bool is_symlink;  // 新增：是否为符号链接
    struct inode *target;  // 新增：符号链接目标inode缓存
};
```

#### 4. 扩展stat结构

```c
struct stat {
    uint32_t st_dev;
    uint32_t st_ino;
    uint32_t st_mode;
    uint32_t st_nlinks;
    uint32_t st_size;
    uint32_t st_blocks;
    uint32_t st_atime;
    uint32_t st_mtime;
    uint32_t st_ctime;
    uint32_t st_rdev;  // 新增：设备号
    uint32_t st_uid;   // 新增：用户ID
    uint32_t st_gid;   // 新增：组ID
};
```

### 三、接口设计

#### 1. 创建硬链接接口

```c
int sys_link(const char *oldpath, const char *newpath);
```

**语义：**
- 为oldpath创建一个新的硬链接newpath
- newpath和oldpath指向同一个inode
- 成功返回0，失败返回错误码

**实现要点：**
1. 查找oldpath对应的inode
2. 检查oldpath是否为目录（不允许对目录创建硬链接）
3. 检查newpath的父目录是否存在
4. 检查newpath是否已存在
5. 在newpath的父目录中创建新的目录项
6. 增加inode的链接计数(nlinks)
7. 同步inode到磁盘

#### 2. 创建软链接接口

```c
int sys_symlink(const char *target, const char *linkpath);
```

**语义：**
- 创建一个符号链接linkpath，指向target
- linkpath是一个特殊文件，内容是target的路径字符串
- 成功返回0，失败返回错误码

**实现要点：**
1. 检查linkpath的父目录是否存在
2. 检查linkpath是否已存在
3. 创建新的inode，类型为SFS_TYPE_SYMLINK
4. 将target路径写入inode的数据块
5. 在linkpath的父目录中创建目录项
6. 同步inode到磁盘

#### 3. 解除链接接口

```c
int sys_unlink(const char *pathname);
```

**语义：**
- 删除pathname对应的目录项
- 如果是硬链接，减少inode的链接计数
- 如果链接计数为0，删除文件数据
- 如果是符号链接，直接删除符号链接文件
- 成功返回0，失败返回错误码

**实现要点：**
1. 查找pathname对应的inode
2. 检查是否有删除权限
3. 从父目录中删除目录项
4. 如果是硬链接：
   - 减少inode的链接计数(nlinks--)
   - 如果nlinks为0，释放数据块和inode
5. 如果是符号链接：
   - 直接释放inode和数据块
6. 同步修改到磁盘

#### 4. 读取链接接口

```c
int sys_readlink(const char *pathname, char *buf, size_t bufsiz);
```

**语义：**
- 读取符号链接pathname指向的目标路径
- 将目标路径复制到buf中
- 返回实际复制的字节数

**实现要点：**
1. 查找pathname对应的inode
2. 检查是否为符号链接类型
3. 从inode的数据块读取目标路径
4. 复制到buf，最多bufsiz字节
5. 返回实际读取的字节数

#### 5. 路径解析扩展接口

```c
int vfs_lookup_follow(struct inode *dir, char *path, 
                     struct inode **node_store, bool follow);
```

**语义：**
- 查找path对应的inode
- 如果follow为true且遇到符号链接，则递归解析
- 返回最终的inode

**实现要点：**
1. 解析路径，逐级查找
2. 如果遇到符号链接且follow为true：
   - 读取符号链接的目标路径
   - 递归调用vfs_lookup_follow解析目标路径
3. 防止循环链接（设置最大递归深度）
4. 返回最终的inode

### 四、同步互斥处理

#### 1. 硬链接的同步问题

**问题场景：**
- 多个进程同时创建/删除硬链接
- 需要保证链接计数的正确性

**解决方案：**

```c
struct sfs_fs {
    ...
    semaphore_t mutex_sem;  // 已有：用于link/unlink和rename操作
    ...
};
```

**同步规则：**
1. 在创建硬链接时：
   - 获取fs->mutex_sem
   - 查找目标inode
   - 增加nlinks计数
   - 创建目录项
   - 释放fs->mutex_sem

2. 在删除硬链接时：
   - 获取fs->mutex_sem
   - 查找目标inode
   - 减少nlinks计数
   - 删除目录项
   - 如果nlinks为0，释放数据块
   - 释放fs->mutex_sem

#### 2. 软链接的同步问题

**问题场景：**
- 多个进程同时读取/解析符号链接
- 需要保证目标路径的一致性

**解决方案：**

使用inode级别的信号量：

```c
struct sfs_inode {
    ...
    semaphore_t sem;  // 已有：保护din的访问
    ...
};
```

**同步规则：**
1. 在读取符号链接时：
   - 获取inode->sem
   - 读取目标路径
   - 释放inode->sem

2. 在创建符号链接时：
   - 获取inode->sem
   - 写入目标路径
   - 释放inode->sem

#### 3. 目录操作的同步

**问题场景：**
- 多个进程同时修改同一目录
- 需要保证目录项的一致性

**解决方案：**

使用文件系统级别的互斥锁：

```c
struct sfs_fs {
    ...
    semaphore_t fs_sem;  // 已有：文件系统互斥锁
    ...
};
```

**同步规则：**
1. 在修改目录时（创建/删除目录项）：
   - 获取fs->fs_sem
   - 修改目录内容
   - 同步到磁盘
   - 释放fs->fs_sem

#### 4. 循环链接检测

**问题场景：**
- 符号链接可能形成循环
- 递归解析时可能导致无限递归

**解决方案：**

```c
#define MAX_LINK_DEPTH 8

int vfs_lookup_follow(struct inode *dir, char *path, 
                     struct inode **node_store, bool follow, int depth) {
    if (depth > MAX_LINK_DEPTH) {
        return -E_LOOP;
    }
    
    // 查找路径
    // 如果遇到符号链接且follow为true：
    //   读取目标路径
    //   递归调用vfs_lookup_follow，depth+1
}
```

#### 5. 原子性保证

**问题场景：**
- 创建硬链接需要多个步骤
- 中途失败可能导致不一致

**解决方案：**

采用写前日志(WAL)或事务机制：

```c
int sys_link(const char *oldpath, const char *newpath) {
    // 1. 预检查所有条件
    // 2. 分配必要的资源
    // 3. 执行原子操作
    // 4. 如果失败，回滚所有修改
}
```

### 五、实现流程

#### 创建硬链接流程

```
sys_link(oldpath, newpath)
  ├─ 获取fs->mutex_sem
  ├─ 查找oldpath对应的inode
  ├─ 检查是否为目录（不允许）
  ├─ 查找newpath的父目录
  ├─ 检查newpath是否已存在
  ├─ 在父目录中创建新的目录项
  ├─ 增加inode的nlinks计数
  ├─ 同步inode到磁盘
  └─ 释放fs->mutex_sem
```

#### 创建软链接流程

```
sys_symlink(target, linkpath)
  ├─ 获取fs->mutex_sem
  ├─ 查找linkpath的父目录
  ├─ 检查linkpath是否已存在
  ├─ 创建新的inode（类型SFS_TYPE_SYMLINK）
  ├─ 分配数据块
  ├─ 将target路径写入数据块
  ├─ 在父目录中创建目录项
  ├─ 同步inode和数据块到磁盘
  └─ 释放fs->mutex_sem
```

#### 删除链接流程

```
sys_unlink(pathname)
  ├─ 获取fs->mutex_sem
  ├─ 查找pathname对应的inode
  ├─ 检查是否有删除权限
  ├─ 从父目录中删除目录项
  ├─ 如果是硬链接：
  │   ├─ 减少nlinks计数
  │   └─ 如果nlinks为0，释放数据块和inode
  ├─ 如果是符号链接：
  │   └─ 直接释放inode和数据块
  ├─ 同步修改到磁盘
  └─ 释放fs->mutex_sem
```

#### 路径解析流程（跟随符号链接）

```
vfs_lookup_follow(dir, path, node_store, follow, depth)
  ├─ 检查depth > MAX_LINK_DEPTH
  ├─ 解析路径，逐级查找
  ├─ 如果遇到符号链接且follow为true：
  │   ├─ 获取inode->sem
  │   ├─ 读取目标路径
  │   ├─ 释放inode->sem
  │   └─ 递归调用vfs_lookup_follow，depth+1
  └─ 返回最终的inode
```

### 六、与VFS的集成

#### 1. 扩展inode操作

```c
struct inode_ops {
    ...
    int (*vop_link)(struct inode *node, const char *name, 
                    struct inode *link_node);
    int (*vop_unlink)(struct inode *node, const char *name);
    int (*vop_symlink)(struct inode *node, const char *name,
                       const char *target);
    int (*vop_readlink)(struct inode *node, char *buf, size_t len);
    ...
};
```

#### 2. 扩展VFS接口

```c
int vfs_link(const char *oldpath, const char *newpath);
int vfs_symlink(const char *target, const char *linkpath);
int vfs_unlink(const char *pathname);
int vfs_readlink(const char *pathname, char *buf, size_t bufsiz);
int vfs_lookup_follow(struct inode *dir, char *path, 
                     struct inode **node_store, bool follow);
```

### 七、硬链接与软链接的区别

| 特性 | 硬链接 | 软链接 |
|------|--------|--------|
| inode | 多个目录项共享同一个inode | 有独立的inode |
| 数据块 | 共享相同的数据块 | 存储目标路径字符串 |
| 跨文件系统 | 不支持 | 支持 |
| 链接目录 | 不允许 | 允许 |
| 删除原文件 | 不影响其他硬链接 | 链接失效（dangling） |
| 链接计数 | 增加nlinks | 不影响nlinks |
| 文件大小 | 与原文件相同 | 目标路径长度 |

### 八、测试用例

#### 1. 硬链接测试

```c
// 创建文件
int fd = open("file.txt", O_CREAT | O_WRONLY);
write(fd, "hello", 5);
close(fd);

// 创建硬链接
link("file.txt", "hardlink.txt");

// 验证：两个文件inode相同
stat("file.txt", &st1);
stat("hardlink.txt", &st2);
assert(st1.st_ino == st2.st_ino);
assert(st1.st_nlink == 2);

// 删除原文件
unlink("file.txt");

// 验证：硬链接仍然可用
fd = open("hardlink.txt", O_RDONLY);
read(fd, buf, 5);
assert(strcmp(buf, "hello") == 0);
```

#### 2. 软链接测试

```c
// 创建文件
int fd = open("file.txt", O_CREAT | O_WRONLY);
write(fd, "hello", 5);
close(fd);

// 创建软链接
symlink("file.txt", "symlink.txt");

// 验证：通过软链接访问
fd = open("symlink.txt", O_RDONLY);
read(fd, buf, 5);
assert(strcmp(buf, "hello") == 0);

// 删除原文件
unlink("file.txt");

// 验证：软链接失效
fd = open("symlink.txt", O_RDONLY);
assert(fd < 0);  // 应该失败
```

---

## 总结

### Challenge1：PIPE机制

**核心要点：**
1. 使用环形缓冲区实现管道
2. 采用生产者-消费者模型
3. 使用三个信号量实现同步互斥
4. 处理管道满、管道空、端点关闭等边界情况
5. 与VFS层集成，提供统一的文件接口

### Challenge2：软连接和硬连接机制

**核心要点：**
1. 硬链接：共享inode和数据块，增加链接计数
2. 软链接：独立的inode，存储目标路径
3. 使用文件系统级和inode级信号量保证同步
4. 实现循环链接检测
5. 提供link、unlink、symlink、readlink等系统调用

**同步互斥处理：**
- 硬链接操作：使用fs->mutex_sem保护链接计数
- 软链接操作：使用inode->sem保护目标路径
- 目录操作：使用fs->fs_sem保护目录项
- 循环链接：设置最大递归深度
